---
sidebar_position: 2
title: Java Thread
slug: thread
---

## 1. Introduction

The `Thread` class in Java represents the smallest unit of execution in a program. It allows concurrent execution of multiple tasks, sharing the same process memory space. Understanding `Thread` is essential for mastering Java concurrency, as it forms the foundation for higher-level frameworks like `ExecutorService`, `ForkJoinPool`, and `Virtual Threads`.

---

## 2. Thread Fundamentals

Every thread in Java is an independent path of execution within a process. A program begins with the **main thread**, which can create additional threads to perform tasks concurrently.

### Key Properties

- Each thread runs a single task defined by a `Runnable` or by overriding `run()`.
- Threads share memory but maintain independent call stacks.
- Thread scheduling and execution order are managed by the **JVM and OS scheduler**, not the developer.

### Example

```java
class Worker extends Thread {
    public void run() {
        System.out.println("Task running in: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Worker worker = new Worker();
        worker.start(); // Start the thread
        System.out.println("Main thread: " + Thread.currentThread().getName());
    }
}
```

üí° **Note:** Calling `start()` creates a new thread, while calling `run()` directly executes the method in the **current** thread ‚Äî no new thread is created.

---

## 3. Thread Lifecycle

A thread‚Äôs lifecycle is managed internally by the JVM. The states are defined in the `Thread.State` enum.

| State             | Description                                                                  |
| ----------------- | ---------------------------------------------------------------------------- |
| **NEW**           | Thread object is created but not yet started.                                |
| **RUNNABLE**      | Thread is ready or running ‚Äî actual execution determined by scheduler.       |
| **BLOCKED**       | Thread is waiting to acquire a monitor lock.                                 |
| **WAITING**       | Thread is waiting indefinitely for another thread‚Äôs action (e.g., `wait()`). |
| **TIMED_WAITING** | Thread is waiting for a specific time (e.g., `sleep(1000)`).                 |
| **TERMINATED**    | Thread has completed execution or exited due to an exception.                |

### Example: Visualizing Lifecycle

```java
Thread t = new Thread(() -> System.out.println("Running"));
System.out.println(t.getState()); // NEW
t.start();
System.out.println(t.getState()); // RUNNABLE or TERMINATED (depends on timing)
```

‚öôÔ∏è **Compiler Behavior:** The JVM tracks thread state transitions internally; developers cannot manually change them.

---

## 4. Thread Priority

Thread priorities influence the scheduler‚Äôs choice of which thread to run first. However, **they are merely hints** ‚Äî the JVM may ignore them depending on the underlying OS.

| Constant        | Value | Meaning          |
| --------------- | ----- | ---------------- |
| `MIN_PRIORITY`  | 1     | Lowest priority  |
| `NORM_PRIORITY` | 5     | Default priority |
| `MAX_PRIORITY`  | 10    | Highest priority |

### Example

```java
Thread t1 = new Thread(() -> System.out.println("Low priority"));
Thread t2 = new Thread(() -> System.out.println("High priority"));

t1.setPriority(Thread.MIN_PRIORITY);
t2.setPriority(Thread.MAX_PRIORITY);

t1.start();
t2.start();
```

‚ö†Ô∏è **Edge Case:** High priority does not guarantee earlier execution ‚Äî OS-level scheduling can override it.

---

## 5. Thread Constructors

Threads can be constructed in several ways depending on the execution target and naming.

| Constructor                            | Description                                           |
| -------------------------------------- | ----------------------------------------------------- |
| `Thread()`                             | Creates a new thread with default name and no target. |
| `Thread(Runnable target)`              | Executes the target‚Äôs `run()` method when started.    |
| `Thread(Runnable target, String name)` | Same as above but assigns a custom name.              |
| `Thread(String name)`                  | Creates a named thread with no target.                |

### Example

```java
Runnable task = () -> System.out.println(Thread.currentThread().getName() + " executing task.");
Thread t = new Thread(task, "Worker-1");
t.start();
```

üí° **Best Practice:** Always assign meaningful thread names to simplify debugging and log tracing.

---

## 6. Important Static Methods

The `Thread` class provides several static utility methods to manage thread behavior globally.

| Method               | Description                                                    |
| -------------------- | -------------------------------------------------------------- |
| `currentThread()`    | Returns a reference to the currently executing thread.         |
| `sleep(long millis)` | Temporarily pauses execution for the specified time.           |
| `yield()`            | Hints the scheduler to give other threads a chance to execute. |
| `onSpinWait()`       | Optimized CPU spin-wait hint introduced in Java 9.             |

### Example

```java
for (int i = 0; i < 3; i++) {
    System.out.println(Thread.currentThread().getName() + " - tick " + i);
    Thread.sleep(500); // Pause for 0.5 seconds
}
```

‚öôÔ∏è **Compiler Note:** `sleep()` doesn‚Äôt release locks; it only pauses the current thread.

---

## 7. The Interrupt Mechanism

Thread interruption is a cooperative mechanism to stop or signal a running thread. It doesn‚Äôt forcibly terminate a thread ‚Äî instead, it sets an internal flag that the thread can check.

### Example

```java
class InterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Working...");
            }
            System.out.println("Stopped safely.");
        });

        worker.start();
        Thread.sleep(1000);
        worker.interrupt(); // Request stop
    }
}
```

üí° **Key Concept:** The `interrupt()` method sets the interrupt flag. Methods like `sleep()` or `wait()` respond by throwing `InterruptedException` and clearing the flag.

### Distinguishing `interrupt()` vs `interrupted()`

| Method          | Type            | Effect                                                          |
| --------------- | --------------- | --------------------------------------------------------------- |
| `interrupt()`   | Instance method | Sets the interrupt flag of the target thread.                   |
| `interrupted()` | Static method   | Checks and **clears** the interrupt flag of the current thread. |

‚ö†Ô∏è **Edge Case:** Calling `interrupt()` on another thread doesn‚Äôt guarantee immediate termination ‚Äî the target thread must cooperatively check its status.

---

## 8. Edge Cases and Internal Behavior

- **Calling `start()` twice:** Throws `IllegalThreadStateException` ‚Äî a thread can only start once.
- **Thread safety:** Multiple threads writing shared data without synchronization can lead to race conditions.
- **Memory visibility:** Without synchronization, changes made by one thread may not be visible to another.
- **Finalization:** Once a thread terminates, it cannot be restarted.

‚öôÔ∏è **Compiler Behavior Insight:** The JVM uses a combination of native and managed calls for thread scheduling. Thread objects remain in memory until garbage collected, even after termination.
